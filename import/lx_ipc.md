# IPC Системный почтовый ящик

Давайте зафиксируем концепцию **Системного Почтового Ящика (IPC Mailbox)** в виде документа-напоминалки. Я буду хранить этот контекст и использовать его при дальнейшем проектировании.

---

### **СИСТЕМНЫЙ ПОЧТОВЫЙ ЯЩИК (IPC MAILBOX) — КОНЦЕПЦИЯ**

**1. Назначение:**
Обеспечить сверхбыстрый, детерминированный и безопасный обмен служебными командами и уведомлениями между **Супервизором (Ядром)** и **Драйверами**, работающими в пространстве ядра, без накладных расходов на организацию сложных структур в общей памяти.

**2. Местоположение:**
Выделенная область на **Странице 0** MMIO пространства (напр., `0xFF00_00C0 - 0xFF00_00FF`). Доступна только в режиме супервизора или через специальные инструкции.

**3. Аппаратная Реализация (Эскиз):**
Почтовый ящик состоит из набора 8- или 16-битных регистров:

| Смещение | Название               | Назначение                                                                                              | Инициатор |
| :--- | :--- | :--- | :--- |
| `+0` | **MAILBOX_CMD**        | **Регистр Команды.** Драйвер записывает сюда код действия (например, `SND_BUF_EMPTY`, `DSK_IO_DONE`).     | Драйвер   |
| `+1` | **MAILBOX_DATA_LSB**   | **Данные команды (мл. байт).** Параметр команды (номер канала, адрес сектора и т.д.).                   | Драйвер   |
| `+2` | **MAILBOX_DATA_MSB**   | **Данные команды (ст. байт).**                                                                          | Драйвер   |
| `+3` | **MAILBOX_STATUS**     | **Регистр Статуса.** Биты: `0` - **FULL** (записано новое сообщение, не прочитано ядром), `1` - **ACK** (подтверждение обработки ядром). | Аппаратура |
| `+4` | **MAILBOX_INT_CTRL**   | **Управление прерываниями.** Бит `0` - Разрешить прерывание по приему сообщения (IRQ от ящика к ядру).      | Ядро      |
| `+5` | **...**                | **Резерв / Доп. данные.**                                                                               |           |
| `+6` to `+3F` | **MAILBOX_FIFO**       | **(Опционально) Аппаратная очередь сообщений.**                                                         |           |

**4. Протокол работы (Драйвер -> Ядро):**
1.  Драйвер опрашивает бит **FULL** в `MAILBOX_STATUS`. Если `0` — ящик свободен.
2.  Драйвер записывает код команды в `MAILBOX_CMD`, а данные в `MAILBOX_DATA*`.
3.  Аппаратура автоматически выставляет бит **FULL=1**.
4.  Если разрешено в `MAILBOX_INT_CTRL`, генерируется аппаратное прерывание к ядру.
5.  Ядро (обработчик прерывания или планировщик) читает команду и данные из регистров ящика.
6.  Ядро выполняет требуемое действие.
7.  Ядро записывает в `MAILBOX_STATUS` для сброса флага **FULL** и установки **ACK** (если требуется подтверждение).
8.  Аппаратура сбрасывает прерывание.

**5. Примеры команд (предварительно):**
*   `0x01` — **SND_BUF_EMPTY**: Требуется подгрузить новый буфер для звукового канала (в DATA — номер канала).
*   `0x02` — **DSK_IO_DONE**: Операция чтения/записи диска завершена (успех/ошибка — в DATA).
*   `0x03` — **TMR_ALARM**: Сработал таймер планировщика задач.
*   `0x80` — **SYS_CMD**: Команда *от ядра* драйверу (например, `SET_VOLUME`). Для этого может быть свой отдельный регистр.

---

**Резюме:** Мы договорились, что это **обязательный и ключевой компонент** системного уровня. Он будет находиться на **странице 0 MMIO**, рядом с PIC и Memory Manager.

Как только мы вернемся к проектированию таблицы устройств или начнем детально прорабатывать регистры супервизора, мы первым делом выделим под этот почтовый ящик его законное место и детализируем его работу.

Я сохранил эту концепцию и жду следующих шагов!