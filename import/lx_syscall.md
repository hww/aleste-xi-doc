# Механизмы переключения режимов в Aleste LX

## 5.1. Программное переключение режимов

**Порт:** `GLOBAL_CTRL` (адрес `F0h` в Native Mode, `F000h` в Legacy Mode)

**Биты регистра:**
Правильно, исправляю - User Lock это бит 4:

```
7 6 5 4 3 2 1 0
│ │ │ │ │ │ │ └─ Supervisor Mode (0=User, 1=Supervisor)
│ │ │ │ │ │ └─── Native Mode (0=Legacy, 1=Native)
│ │ │ │ │ └───── Supervisor Hook Enable (0=Disable, 1=Enable)
│ │ │ │ └─────── Reserved (должен быть 0)
│ │ │ └───────── User Lock (0=Unlocked, 1=Locked)
└─┴─┴─────────── Reserved (должны быть 0)
```

## 5.1.1. Расширенное описание регистра GLOBAL_CTRL

### **Биты управления:**

**bit0 - Supervisor Mode** (0=User, 1=Supervisor)
- Определяет текущий режим исполнения
- В Supervisor Mode доступны все системные регистры
- В User Mode доступ ограничен

**bit1 - Native Mode** (0=Legacy, 1=Native)
- Legacy Mode: 64К адресное пространство, порты 0000h-FFFFh
- Native Mode: 4М адресное пространство, порты 00h-FFh
- Трансляция адресов портов: Legacy порт = Native порт × 256

**bit2 - Supervisor Hook Enable** (0=Disable, 1=Enable)
- Разрешает аппаратное переключение в Supervisor Mode при:
  - Доступе к адресам 0038h (IM1) или 0066h (NMI)
  - Только когда M1 цикл активен
- Позволяет ядру перехватывать обработку прерываний

**bit4 - User Lock** (0=Unlocked, 1=Locked) ⭐ **НОВЫЙ БИТ**
- **Назначение:** Предотвращает случайный или несанкционированный выход из User Mode
- **Поведение:**
  - Когда установлен (1): запись в GLOBAL_CTRL из User Mode игнорируется или вызывает исключение
  - Когда сброшен (0): обычное поведение
- **Использование:**
  - Ядро устанавливает User Lock при запуске пользовательского процесса
  - Пользовательский процесс не может изменить режимы
  - Только Supervisor Mode может изменить этот бит
- **Мотивация:** Усиление безопасности, предотвращение привилегийных escalation атак

### **Битовая маска для удобства:**

```asm
; Константы для GLOBAL_CTRL
GCTRL_SUPERVISOR  equ 0b00000001
GCTRL_NATIVE      equ 0b00000010
GCTRL_HOOK        equ 0b00000100
GCTRL_USER_LOCK   equ 0b00010000
```

### **Примеры использования:**

```asm
; ===== SUPERVISOR MODE (ядро) =====

; Инициализация: Native + Supervisor + Hook включен
LD A, GCTRL_SUPERVISOR | GCTRL_NATIVE | GCTRL_HOOK  ; 00000111b
OUT (F0h), A

; Подготовка к запуску пользовательского процесса:
; 1. Сбрасываем Supervisor, оставляем Native, включаем Lock
LD A, GCTRL_NATIVE | GCTRL_USER_LOCK  ; 00010010b
OUT (F0h), A     ; User Mode с заблокированным переключением

; Теперь пользователь не может изменить режим!

; Для обработки прерываний в пользовательском процессе:
; 1. Включаем Hook (разрешаем переход в супервизор по прерываниям)
LD A, GCTRL_NATIVE | GCTRL_HOOK | GCTRL_USER_LOCK  ; 00010110b
OUT (F0h), A

; Возврат в полный Supervisor Mode (разблокировка + супервизор)
LD A, GCTRL_SUPERVISOR | GCTRL_NATIVE | GCTRL_HOOK  ; 00000111b
OUT (F0h), A
```

### **Аппаратная логика User Lock:**

```verilog
// Обработка записи в GLOBAL_CTRL
always @(posedge clk) begin
    if (io_write && io_addr == GLOBAL_CTRL_PORT) begin
        if (supervisor_mode == 0 && data_in[4] == 1) begin
            // User пытается установить User Lock - игнорируем или вызываем trap
            // (зависит от реализации)
        end else if (supervisor_mode == 1) begin
            // Супервизор может делать что угодно
            global_ctrl <= data_in;
        end else begin
            // User mode без Lock - разрешаем изменение
            global_ctrl <= data_in;
        end
    end
end

// Проверка на изменение режима из User Mode
wire user_mode_change_attempt = (supervisor_mode == 0) && 
                                (global_ctrl[0] != new_supervisor_bit);
                                
if (user_mode_change_attempt && global_ctrl[4] == 1) begin
    // User пытается изменить режим при установленном Lock
    // Вызываем trap или игнорируем
end
```

### **Практические сценарии:**

```asm
; Сценарий 1: Безопасный пользовательский процесс
; Ядро запускает:
    LD A, GCTRL_NATIVE | GCTRL_USER_LOCK
    OUT (F0h), A     ; Запуск с защитой
    
; Пользователь пытается схитрить:
    LD A, GCTRL_SUPERVISOR | GCTRL_NATIVE
    OUT (F0h), A     ; Игнорируется! Остаёмся в User Mode

; Сценарий 2: Доверенный системный вызов
; Пользователь вызывает Syscall:
    OUT (F2h), A     ; Переходит в Supervisor Mode
                     ; Ядро временно снимает User Lock
                     ; Обрабатывает вызов
                     ; Возвращает с установленным Lock

; Сценарий 3: Обработка прерывания
; User Lock установлен, Hook включен
; Приходит прерывание → автоматический переход в Supervisor
; Ядро обрабатывает → возвращает в User с Lock
```

**Преимущества User Lock:**
1. **Защита от случайных изменений** - пользовательский код не может "случайно" переключить режим
2. **Предотвращение атак** - усложняет эксплуатацию уязвимостей
3. **Детерминизм** - гарантированное состояние системы
4. **Простота реализации** - минимальные аппаратные затраты

Такой порядок битов логичен и функционален. User Lock на бите 4 хорошо отделён от основных битов управления, что упрощает маскирование.

**Мотивация:** 
- Отдельные биты для Native/Supervisor обеспечивают гибкость переключения
- "Hook Enable" бит позволяет динамически включать/выключать аппаратное перехватывание прерываний
- Legacy Mode поддержка через трансляцию адресов обеспечивает обратную совместимость

```asm
; Активация Native + Supervisor режимов
LD A, 00000111b  ; Native=1, Supervisor=1, Hook=1
OUT (F0h), A

; Возврат в User Mode (остаёмся в Native)
LD A, 00000001b  ; Native=1, Supervisor=0, Hook=0
OUT (F0h), A
```

## 5.2. Аппаратное переключение (Trap) в Supervisor Mode

**Назначение:** Автоматический переход в Supervisor Mode при срабатывании прерываний или сбросе.

**Условие срабатывания:**
```
trap_trigger = (supervisor_hook == 1) ∧ 
               (M1_cycle_active) ∧ 
               (address_bus == 0038h ∨ address_bus == 0066h)
```

**Мотивация выбора адресов 0038h и 0066h:**
1. **0038h** - стандартный вектор IM1 прерывания Z80, гарантированно используется в Legacy-программах
2. **0066h** - вектор NMI, используется для критических событий
3. Оба адреса стандартизированы в архитектуре Z80, не требуют резервирования дополнительных адресов
4. Прерывания уже являются защищённым механизмом (управляются через EI/DI)

**Преимущества:**
- Минимальные аппаратные затраты (только 2 компаратора)
- Прозрачность для пользовательского кода
- Естественная интеграция с существующей экосистемой Z80

**Особенность:** Trap работает ТОЛЬКО когда `supervisor_hook == 1`. Это позволяет ядру контролировать, когда разрешён автоматический переход.

## 5.3. Системные вызовы (Syscall)

### 5.3.1. Назначение и философия

**Проблема, которую решает Syscall:** 
Как предоставить пользовательским программам доступ к функциям ядра, сохраняя при этом:
1. **Безопасность** - защиту от произвольного выполнения кода ядра
2. **Производительность** - минимальные накладные расходы
3. **Надёжность** - предсказуемое поведение при DI/NMI
4. **Совместимость** - работу в обоих режимах (Native/Legacy)

### 5.3.2. Выбор механизма

**Рассмотренные варианты:**

| Вариант | Преимущества | Недостатки | Почему не выбран |
|---------|-------------|------------|------------------|
| **RST инструкции** | Стандартный, простой | DI блокирует, конфликты с Legacy-кодом | Ненадёжность при DI |
| **CALL на фикс. адрес** | Предсказуемость | Требует резервирования адреса, сложная защита | Конфликты с Legacy-памятью |
| **NMI (RST 66h)** | Работает всегда | Катастрофические события, сложная вложенность | Нарушение семантики NMI |
| **OUT в спец. порт** | Атомарность, работает с DI, минимальные аппаратные затраты | Теоретическая уязвимость произвольного вызова | **ВЫБРАН: преимущества перевешивают** |

**Итоговое решение:** `OUT` в специальный порт как оптимальный баланс между простотой, надёжностью и производительностью.

### 5.3.3. Детали реализации

**Порты Syscall:**
- **Native Mode:** `F2h`
- **Legacy Mode:** `F200h` (транслируется аппаратно)

**Аппаратная логика:**
```verilog
// Native Mode
if (io_write && io_addr == 8'hF2 && supervisor_mode == 0) begin
    syscall_trigger <= 1;
    syscall_function <= data_bus;  // Сохраняем номер функции
    supervisor_mode <= 1;          // Немедленный переход в супервизор
    saved_user_pc <= pc + 3;       // PC после RET (CALL+OUT+RET)
    cpu_pc <= SYSCALL_VECTOR;      // Переход на обработчик
end

// Legacy Mode (аналогично с трансляцией адреса)
if (io_write && io_addr == 16'hF200 && supervisor_mode == 0) begin
    // Та же логика
end
```

**Мотивация выбора порта F2h/F200h:**
1. Вне стандартного диапазона портов Z80 (00h-FFh в Legacy Mode)
2. Простая трансляция для Legacy Mode (добавление 00h)
3. Не конфликтует с типичными периферийными устройствами

### 5.3.4. Соглашение о вызовах

**Передача аргументов через регистры (а не через порт):**

**Почему регистры, а не порт?**
1. **Стандартность** - соответствует соглашениям CP/M, MSX-DOS, Unix
2. **Производительность** - регистры быстрее портов
3. **Удобство** - программисты привыкли к этой модели
4. **Гибкость** - возможность передачи структур через указатели

**Стандартное соглашение:**
```asm
; ПЕРЕД вызовом Syscall:
LD A, function_code    ; Код функции (обязательно)
LD BC, argument1       ; Первый аргумент
LD DE, argument2       ; Второй аргумент  
LD HL, argument3       ; Третий аргумент
CALL syscall_wrapper   ; Вызов обёртки

; ПОСЛЕ Syscall:
; A = код возврата (0=успех, иначе ошибка)
; HL = дополнительный результат (если нужен)
; Другие регистры сохраняются
```

**Сохраняемые регистры:**
- **Сохраняются ядром:** BC, DE, HL, IX, IY, AF', BC', DE', HL'
- **Могут изменяться:** A (код возврата), HL (доп. результат при успехе)
- **FLAGS:** устанавливаются согласно результату

### 5.3.5. Обёртка Syscall

**Обязательная обёртка в пользовательском коде:**
```asm
syscall_wrapper:
    ; Эта обёртка ВСЕГДА должна использоваться для вызова Syscall
    OUT (F2h), A    ; 1. Передача номера функции + переход в супервизор
    RET             ; 2. Сюда вернётся управление после обработки
```

**Зачем нужна обёртка?**
1. **Единая точка входа** - упрощает отладку и трассировку
2. **Гарантированный RET** - обеспечивает корректный возврат
3. **Место для расширения** - можно добавить логирование, проверки
4. **Абстракция режима** - одна реализация для Native/Legacy

**НЕВЕРНО (вызов напрямую):**
```asm
OUT (F2h), A  ; Опасность: следующий код зависит от реализации
```

**ПРАВИЛЬНО (через обёртку):**
```asm
CALL syscall_wrapper  ; Гарантированное поведение
```

### 5.3.6. Обработчик Syscall в супервизоре

**Расположение:** Фиксированный адрес (например, 0100h) в Supervisor Memory Space

**Структура обработчика:**
```asm
Syscall_Dispatcher:
    ; Входные условия:
    ; - Режим: Supervisor Mode
    ; - A: код функции (из порта F2h)
    ; - BC, DE, HL: аргументы (из пользовательских регистров)
    ; - PC возврата: сохранён в стеке (от CALL в обёртке)
    
    ; Сохраняем ВСЕ регистры, которые будем использовать
    PUSH BC
    PUSH DE
    PUSH HL
    PUSH IX
    PUSH IY
    EX AF, AF'
    EXX
    PUSH AF
    PUSH BC
    PUSH DE
    PUSH HL
    
    ; Диспетчеризация по коду функции
    CP SYS_OPEN
    JP Z, Syscall_OpenFile
    CP SYS_READ
    JP Z, Syscall_ReadFile
    CP SYS_WRITE
    JP Z, Syscall_WriteFile
    ; ... другие функции
    
    ; Неизвестная функция
    LD A, ERR_UNKNOWN_FUNCTION
    JR syscall_return

Syscall_WriteFile:
    ; BC = file_handle
    ; DE = data_size
    ; HL = data_buffer
    
    ; 1. Проверка параметров
    ; 2. Выполнение операции
    ; 3. Установка кода возврата
    
    LD A, 0  ; Успех
    ; JR syscall_return

syscall_return:
    ; Восстанавливаем регистры в ОБРАТНОМ порядке
    POP HL
    POP DE
    POP BC
    POP AF
    EXX
    EX AF, AF'
    POP IY
    POP IX
    POP HL
    POP DE
    POP BC
    
    ; A содержит код возврата
    ; Подготавливаем выход из супервизора
    PUSH AF          ; Сохраняем код возврата
    LD A, 00000000b  ; Supervisor=0 (готовим выход)
    OUT (F0h), A     ; Устанавливаем флаг выхода
    POP AF           ; Восстанавливаем код возврата
    RET              ; Критически важно: RET (не RETI/RETN)
```

### 5.3.7. Защита и безопасность

**Миф:** "OUT в порт можно вызвать откуда угодно - это уязвимость"

**Реальность:** Это **фича**, а не баг, по следующим причинам:

1. **Пользовательский код и так выполняется произвольно** - если есть уязвимость, злоумышленник может выполнить любой код
2. **Все опасные операции защищены** - порты MMU, управление прерываниями требуют Supervisor Mode
3. **Syscall handler включает проверки** - валидация параметров, проверка прав доступа
4. **Альтернативы хуже** - RST/CALL требуют резервирования памяти, создают конфликты
5. **Аналоги в современных системах** - x86 SYSCALL/INT, ARM SVC тоже могут вызываться "откуда угодно"

**Дополнительные меры защиты:**
- Валидация всех параметров Syscall
- Проверка прав доступа к ресурсам
- Ограничение системных вызовов в критических секциях
- Аудит вызовов Syscall

## 5.4. Выход из Supervisor Mode

### 5.4.1. Многошаговый процесс выхода

**Проблема:** Нельзя мгновенно переключиться из Supervisor Mode, так как:
1. Текущая команда должна завершиться
2. Нужно гарантировать атомарность переключения
3. Должна сохраниться возможность обработки прерываний

**Решение:** Синхронизированный по M1 циклу многошаговый выход.

**Последовательность выхода:**

```asm
; 1. ИНИЦИАЦИЯ ВЫХОДА (в коде ядра)
LD A, 00000000b  ; Supervisor=0 (остальные биты как нужно)
OUT (F0h), A     ; Устанавливаем флаг EXIT_PENDING
; Аппаратура: EXIT_SUPERVISOR_PENDING = 1

; 2. ФИНАЛЬНАЯ КОМАНДА В СУПЕРВИЗОРЕ
RET              ; Исполняется в Supervisor Mode
; Важно: эта команда ВСЕГДА должна быть RET/RETI/RETN

; 3. СИНХРОНИЗАЦИЯ (аппаратура)
; Ждём следующий M1 цикл

; 4. ПЕРЕКЛЮЧЕНИЕ (аппаратура, при M1)
; supervisor_mode = 0
; Переключаются банки памяти
; PC указывает на адрес возврата в User Mode

; 5. ВЫПОЛНЕНИЕ В USER MODE
; Следующая команда после RET выполняется в User Mode
```

### 5.4.2. Почему именно такая последовательность?

1. **RET в супервизоре** - гарантирует, что стек возврата корректно восстановлен
2. **Синхронизация по M1** - естественная точка переключения в цикле команд Z80
3. **Атомарность** - между установкой флага и переключением не может вклиниться прерывание
4. **Предсказуемость** - всегда одинаковое поведение

### 5.4.3. Обработка прерываний во время выхода

**Сценарий:** Установлен EXIT_PENDING, но до M1 пришло прерывание.

**Поведение:**
1. Прерывание обрабатывается нормально (в Supervisor Mode)
2. После обработки прерывания продолжается выход
3. **Не возникает race condition**

## 5.5. Практические примеры

### 5.5.1. Полный цикл Syscall

**Пользовательская программа:**
```asm
    ; Открытие файла
    LD A, SYS_OPEN
    LD BC, filename_ptr
    LD DE, access_mode
    LD HL, 0          ; Не используется
    CALL syscall_wrapper
    OR A              ; Проверка на ошибку
    JR NZ, error
    LD (file_handle), BC  ; Сохраняем хэндл
    
    ; Чтение файла
    LD A, SYS_READ
    LD BC, (file_handle)
    LD DE, buffer_size
    LD HL, buffer_ptr
    CALL syscall_wrapper
    OR A
    JR NZ, error
    
    ; Закрытие файла
    LD A, SYS_CLOSE
    LD BC, (file_handle)
    CALL syscall_wrapper
```

**Обёртка Syscall (в библиотеке времени выполнения):**
```asm
syscall_wrapper:
    OUT (F2h), A    ; Native Mode
    RET
    
syscall_wrapper_legacy:
    OUT (F200h), A  ; Legacy Mode
    RET
```

### 5.5.2. Обработчик прерываний в ядре

```asm
Interrupt_Handler_38h:
    ; Автоматически в Supervisor Mode
    PUSH AF
    PUSH BC
    PUSH DE
    PUSH HL
    
    ; Определение источника прерывания
    IN A, (INTERRUPT_STATUS)
    
    ; Обработка...
    
    POP HL
    POP DE
    POP BC
    POP AF
    EI
    RETI
```

## 5.6. Рекомендации по использованию

### 5.6.1. Для разработчиков ядра:
1. Всегда используйте стандартное соглашение о вызовах
2. Тщательно проверяйте параметры Syscall
3. Сохраняйте и восстанавливайте все регистры
4. Используйте RET (не RETI/RETN) для возврата из Syscall

### 5.6.2. Для разработчиков приложений:
1. Всегда используйте предоставленную обёртку syscall_wrapper
2. Проверяйте коды возврата
3. Не предполагайте сохранение регистров (кроме оговоренных)
4. Учитывайте режим работы (Native/Legacy)

### 5.6.3. Для разработчиков драйверов:
1. Trap-обработчики должны быть минимальными
2. Используйте Syscall для сложных операций
3. Учитывайте вложенность прерываний

## 5.7. Часто задаваемые вопросы

**Q: Почему не используется RST для Syscall?**
**A:** DI блокирует RST, что делает систему ненадёжной. Syscall должен работать всегда.

**Q: Что если пользователь вызовет OUT (F2h) не через обёртку?**
**A:** Это нарушение контракта. Ядро может детектировать это (проверкой PC) и возвращать ошибку.

**Q: Как быть с реентерабельностью Syscall?**
**A:** Ядро должно обрабатывать реентерабельные вызовы корректно. Рекомендуется использовать неделимые операции.

**Q: Можно ли вызывать Syscall из прерывания?**
**A:** Да, но осторожно. Ядро должно обрабатывать вложенные вызовы.

**Q: Что происходит при Syscall во время выхода из супервизора?**
**A:** Syscall имеет приоритет, обрабатывается, затем продолжается выход.

