# Документация MMU API для Aleste LX

## Оглавление

1. [Обзор](#обзор)
2. [Архитектурные принципы](#архитектурные-принципы)
3. [Порты ввода-вывода](#порты-ввода-вывода)
4. [Функции API](#функции-api)
5. [Примеры использования](#примеры-использования)
6. [Макросы для быстрого доступа](#макросы-для-быстрого-доступа)
7. [Ограничения доступа](#ограничения-доступа)
8. [Рекомендации по использованию](#рекомендации-по-использованию)

## Обзор

Библиотека `mmu_api.asm` предоставляет полный набор функций для управления подсистемой памяти (MMU) платформы Aleste LX. API вдохновлён стандартами MSX, но адаптирован под специфическую архитектуру Aleste LX с поддержкой 4 аппаратных слотов, 256 банков памяти и гибкого переключения режимов работы.

### Ключевые особенности:

- **MSX-совместимый** интерфейс для легкой портируемости
- **Полный контроль** над 16МБ физической памяти
- **Безопасный доступ** с разделением супервизор/пользователь
- **Эффективные операции** для работы с памятью

## Архитектурные принципы

### Терминология Aleste LX:

1. **Слот (Slot)** - Аппаратный слот памяти: `A[23:22]`
   - 4 независимых слота (0-3)
   - Каждый слот содержит 256 банков

2. **Банк (Bank)** - Блок памяти 16КБ в слоте: `A[21:14]`
   - 256 банков на слот (0-255)
   - Всего 1024 банка в системе

3. **Страница (Page)** - Область в логическом пространстве Z80: `A[13:0]`
   - 4 страницы по 16КБ
   - Страница 0: 0000-3FFF
   - Страница 1: 4000-7FFF
   - Страница 2: 8000-BFFF
   - Страница 3: C000-FFFF

### Схема преобразования адресов:

```
Физический адрес = {Слот[1:0], Банк[7:0], CPU_A[13:0]}
```

### Внутренние регистры MMU:

Система содержит 16 внутренних регистров маппера:
```
0xE0-0xE3: Слот 0, Страницы 0-3
0xE4-0xE7: Слот 1, Страницы 0-3
0xE8-0xEB: Слот 2, Страницы 0-3
0xEC-0xEF: Слот 3, Страницы 0-3
```

## Порты ввода-вывода

### Системные порты (Native Mode):

| Порт  | Название          | Назначение                         | Доступ          |
|-------|-------------------|------------------------------------|-----------------|
| `F0h` | `GLOBAL_CTRL`     | Управление режимами                | RW*             |
| `F1h` | `MMIO_PAGE`       | Выбор страницы MMIO                | RW*             |
| `F2h` | `SYSCALL_PORT`    | Системный вызов                    | W               |
| `F3h` | `CLOCK_CTRL`      | Управление частотой CPU            | RW (Supervisor) |
| `F9h` | `SUPER_SLOT_PORT` | Активный слот для супервизора      | RW*             |
| `FBh` | `USER_SLOT_PORT`  | Активный слот для пользователя     | RW*             |
| `FCh` | `BANK_PAGE0_PORT` | Банк для страницы 0 текущего слота | RW*             |
| `FDh` | `BANK_PAGE1_PORT` | Банк для страницы 1 текущего слота | RW*             |
| `FEh` | `BANK_PAGE2_PORT` | Банк для страницы 2 текущего слота | RW*             |
| `FFh` | `BANK_PAGE3_PORT` | Банк для страницы 3 текущего слота | RW*             |

**Примечание:** RW* - чтение/запись с ограничениями по привилегиям.

### Битовая карта GLOBAL_CTRL:

| Бит | Название | Описание |
|-----|----------|----------|
| 0 | `SUPERVISOR_BIT` | 1=Режим супервизора, 0=Пользовательский режим |
| 1 | `NATIVE_MODE_BIT` | 1=Native Mode, 0=Legacy Mode |
| 2 | `TRAP_HOOK_BIT` | 1=Включить аппаратный trap |
| 3 | Зарезервировано | |
| 4 | `MMIO_UNLOCK_BIT` | 1=Разблокировать MMIO для пользователя |
| 5-7 | Зарезервировано | |

## Функции API

### Секция 1: Основное управление MMU

#### `mmu_get_current_slot`

```assembly
; Получить текущий активный слот
; Вход: Нет
; Выход: A = текущий слот (0-3), бит 7 = 1 если супервизор
; Сохраняет: Все, кроме AF
```
Определяет текущий активный слот в зависимости от режима привилегий.

#### `mmu_set_bank_for_page`

```assembly
; Установить банк для страницы ТЕКУЩЕГО СЛОТА
; Вход: A = номер банка (0-255), B = номер страницы (0-3)
; Выход: Нет
; Сохраняет: BC, DE, HL
```
Устанавливает банк памяти для указанной страницы в текущем активном слоте.

#### `mmu_get_bank_for_page`

```assembly
; Получить банк для страницы ТЕКУЩЕГО СЛОТА
; Вход: B = номер страницы (0-3)
; Выход: A = номер банка
; Сохраняет: BC, DE, HL
```
Читает текущий банк для указанной страницы в активном слоте.

#### `mmu_set_all_banks_for_current_slot`

```assembly
; Установить все 4 банка для текущего слота
; Вход: HL = указатель на массив [bank0, bank1, bank2, bank3]
; Выход: Нет
; Сохраняет: Все, кроме AF, BC, HL
```
Быстрая установка всех четырех банков текущего слота.

### Секция 2: Расширенные операции

#### `mmu_set_bank_for_slot_page`

```assembly
; Установить банк для конкретного слота и страницы
; Вход: A = слот (0-3), B = страница (0-3), C = банк (0-255)
; Выход: Нет
; Сохраняет: DE, HL
```
Устанавливает банк для любого слота и страницы, временно переключая активный слот.

#### `mmu_get_bank_for_slot_page`

```assembly
; Получить банк для конкретного слота и страницы
; Вход: A = слот (0-3), B = страница (0-3)
; Выход: A = номер банка
; Сохраняет: DE, HL
```
Читает банк из любого слота и страницы.

#### `mmu_save_full_state`

```assembly
; Сохранить состояние всего маппера (16 регистров)
; Вход: HL = указатель на буфер (16+ байт)
; Выход: Нет
; Сохраняет: Все
```
Сохраняет полное состояние MMU, включая режимы и настройки слотов.

#### `mmu_restore_full_state`

```assembly
; Восстановить состояние всего маппера
; Вход: HL = указатель на буфер (16+ байт)
; Выход: Нет
; Сохраняет: Все
```
Восстанавливает полное состояние MMU из буфера.

### Секция 3: Утилиты для работы с памятью

#### `mmu_map_bank_to_address`

```assembly
; Отобразить банк по конкретному адресу
; Вход: A = номер банка, HL = логический адрес (0000-FFFF)
; Выход: Нет
; Сохраняет: BC, DE
```
Автоматически определяет страницу по адресу и устанавливает банк.

#### `mmu_get_bank_for_address`

```assembly
; Получить банк отображенный по адресу
; Вход: HL = логический адрес
; Выход: A = номер банка
; Сохраняет: BC, DE
```
Определяет какой банк отображен по указанному адресу.

#### `mmu_copy_cross_slot`

```assembly
; Копировать между разными слотами
; Вход: A = слот источника, B = банк источника,
;       C = слот приемника, D = банк приемника,
;       HL = размер (в байтах)
; Выход: Нет
; Сохраняет: Все
```
Копирует данные между банками в разных слотах.

### Секция 4: Управление режимами работы

#### `mmu_set_mode`

```assembly
; Установить режим работы системы
; Вход: A = режим (биты GLOBAL_CTRL)
; Выход: Нет
; Сохраняет: Все, кроме AF
```

#### `mmu_get_mode`

```assembly
; Получить текущий режим работы
; Вход: Нет
; Выход: A = текущий режим
; Сохраняет: Все, кроме AF
```

#### `mmu_enable_native` / `mmu_enable_legacy`

```assembly
; Включить Native/Legacy Mode
; Вход: Нет
; Выход: Нет
; Сохраняет: Все
```

#### `mmu_enable_supervisor` / `mmu_enable_user`

```assembly
; Войти в режим супервизора/пользователя
; Вход: Нет
; Выход: Нет
; Сохраняет: Все
```

#### `mmu_set_clock`

```assembly
; Установить частоту CPU (только в супервизоре!)
; Вход: A = делитель частоты
; Выход: Нет
; Сохраняет: Все, кроме AF
```

### Секция 5: Системные вызовы

#### `syscall`

```assembly
; Выполнить системный вызов
; Вход: A = код функции, BC, DE, HL = параметры
; Выход: A = код результата, HL = доп. результат
```

#### `syscall_mem_alloc`

```assembly
; Выделить память
; Вход: BC = размер в байтах
; Выход: A = статус, HL = указатель/банк
```

#### `syscall_mem_free`

```assembly
; Освободить память
; Вход: BC = указатель/банк
; Выход: A = статус
```

#### `syscall_mmap`

```assembly
; Отобразить банк в логическое пространство
; Вход: A = банк, B = страница, C = слот
; Выход: A = статус
```

#### `syscall_request_mmio`

```assembly
; Запрос доступа к MMIO
; Вход: HL = указатель на подпись, BC = размер
; Выход: A = статус
```

## Примеры использования

### Пример 1: Базовая инициализация MMU

```assembly
    call mmu_init
    
    ; Установить банки для текущего слота
    ld hl, bank_table
    call mmu_set_all_banks_for_current_slot
    
    ; Проверить режим
    call mmu_get_mode
    and 00000010b       ; Проверить Native Mode
    jp z, legacy_mode
    
bank_table:
    db 0x00, 0x01, 0x02, 0x03  ; Банки для страниц 0-3
```

### Пример 2: Работа с несколькими слотами

```assembly
    ; Установить банк 0x10 в страницу 1 слота 2
    ld a, 2            ; Слот 2
    ld b, 1            ; Страница 1
    ld c, 0x10         ; Банк 0x10
    call mmu_set_bank_for_slot_page
    
    ; Прочитать банк из страницы 3 слота 1
    ld a, 1            ; Слот 1
    ld b, 3            ; Страница 3
    call mmu_get_bank_for_slot_page
    ld (saved_bank), a
```

### Пример 3: Сохранение/восстановление состояния

```assembly
    ; Сохранить состояние перед переключением задачи
    ld hl, task_state_buffer
    call mmu_save_full_state
    
    ; ... выполнение другой задачи ...
    
    ; Восстановить оригинальное состояние
    ld hl, task_state_buffer
    call mmu_restore_full_state
```

### Пример 4: Копирование данных между банками

```assembly
    ; Копировать 1024 байта из банка 0x20 слота 1 в банк 0x30 слота 2
    ld a, 1            ; Слот источника
    ld b, 0x20         ; Банк источника
    ld c, 2            ; Слот приемника
    ld d, 0x30         ; Банк приемника
    ld hl, 1024        ; Размер
    call mmu_copy_cross_slot
```

## Макросы для быстрого доступа

Библиотека поддерживает макросы для inline-оптимизации:

```assembly
; Установка банков для конкретных страниц
SET_PAGE0_BANK 0x10     ; Банк 0x10 в страницу 0
SET_PAGE1_BANK 0x20     ; Банк 0x20 в страницу 1
SET_PAGE2_BANK 0x30     ; Банк 0x30 в страницу 2
SET_PAGE3_BANK 0x40     ; Банк 0x40 в страницу 3

; Переключение слота
SWITCH_TO_SLOT 2, 1     ; Переключиться в слот 2 (супервизор)
SWITCH_TO_SLOT 1, 0     ; Переключиться в слот 1 (пользователь)

; Комбинированные операции
SET_BANK_FOR_PAGE 0x55, 2  ; Банк 0x55 в страницу 2
```

## Ограничения доступа

### В зависимости от режима:

| Режим | Доступные порты | Ограничения |
|-------|----------------|-------------|
| **Supervisor Native** | Все порты F0-FF | Нет ограничений |
| **Supervisor Legacy** | Все порты F0-FF | Native режим игнорируется |
| **User Native** | F2 (SYSCALL) | Доступ к MMIO только при mmio_unlock=1 |
| **User Legacy** | F200 (SYSCALL) + CPC порты | Стандартные ограничения CPC |

### Особые случаи:

- `CLOCK_CTRL` (F3h) - только в Supervisor режиме
- `MMU_EXT` область - доступна только CPU, не доступна через DMA
- Системные вызовы - всегда доступны через F2h/F200h

## Рекомендации по использованию

### Для разработчиков драйверов:

1. Всегда проверяйте текущий режим перед доступом к портам
2. Используйте системные вызовы для безопасного доступа из User Mode
3. Сохраняйте/восстанавливайте состояние MMU при переключении задач

### Для прикладных программ:

1. Запрашивайте доступ к MMIO через `syscall_request_mmio`
2. Используйте высокоуровневые функции API вместо прямого доступа к портам
3. Не делайте предположений о текущем состоянии MMU

### Оптимизация производительности:

1. Используйте макросы для критичных по времени операций
2. Кэшируйте часто используемые значения банков
3. Для больших копирований используйте `mmu_copy_cross_slot`

### Совместимость с MSX:

```assembly
; MSX-совместимые функции:
; mmu_enable_slot  - аналог ENASLT
; mmu_read_slot    - аналог RDSLT  
; mmu_write_slot   - аналог WRSLT
; mmu_set_bank_for_page - аналог установки банков
```

## Лицензия и использование

Библиотека распространяется под лицензией MIT. Может свободно использоваться в проектах для Aleste LX.

### Требования:

- Ассемблер с поддержкой стандартного синтаксиса Z80
- Система Aleste LX с обновленной прошивкой
- Понимание архитектуры MMU платформы

### Поддержка:

Вопросы и предложения по API принимаются через репозиторий проекта Aleste LX.

---
*Документация версии 1.0 для Aleste LX MMU API*